/*
*****************************************************************************
                          Workshop - #9(reflect)
Full Name  : yuvraj singh
Student ID#: 155580210
Email      : yuvraj-singh5@myseneca.ca
Date       : 27/11/2022
 
*****************************************************************************
*/

In this workshop I learned process partitioned data on two or more threads, 
how to write and read a set of characters to a file in binary mode, also 
how to bind a function to its arguments.

I had time to read new features of C++ during this workshop such as thread or 
bind. First of all, I dealt with the input and output of files in this workshop, 
but I used binary files differently than usual. The difference between a basic 
file and a binary file is whether the user can see the contents with his or her 
eyes when opening the file.

This difference is why I used this binary file in this workshop. Because it had 
to store secure data, it was saved in binary form so that users could not easily 
read the file. I added a new argument to read or write binary files in the 
ifstream and ofstream. "ios::binary" specifies that the file should be read or 
write in binary form. 

I used "std::bind" for the first time, and the most important thing was to match 
the arguments well. First, std::bind is a function that allows some parameters of 
a function to be set to a fixed value and then once wrapped to be used. To do so, 
put the function and the corresponding arguments in std::bind. 

I used "thread". the thread was familiar because I had used it before. The computer 
executes the program I ordered sequentially. However, it is the tread that commands
a computer to use multiple processes to perform multiple tasks at the same time. 
This process reduces memory space and system resource consumption once it is done 
at once. And even if one thread terminates the task, the other continues to perform 
the task. I used a vector container to store thread as data type to use thread in 
this workshop.  

A total of four threads were implemented, and join() function was used to allow all 
threads to wait for the parent thread to complete the task.


